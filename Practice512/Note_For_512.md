# 内部类
1.  处理复杂问题的时候，需要封装一个类，仅仅辅助当前类来完成工作的，对内部类进行合理的封装不给外部使用。
2.  匿名内部类是为快速生成一个抽象或者正常类子类，或者接口实现类；不需要类文件，通常用于传递方法
3.  内部类编译后一般格式为：外部类$内部类.class；如果是匿名的，格式为：外部类$编号.class
4.  接口中的内部类默认为public的，因此这些内部类可以被其他类使用
5.  无法声明匿名内部类的引用，因此必须使用接口或者父类的对象引用匿名内部类里重写的对象，如果在匿名内部类里面自定义了public的方法，在外部也无法调用，  
    但是可以在new{}.的时候直接调用；
6.  effectily final ：对于匿名内部类（局部内部类）调用的局部变量，不能修改这个变量的值，这个局部变量在编译后变为final的。但是可以调用成员变量
    如果是引用数据类型变量，对于effectily final的变量，不能修改值，但是可以修改其中引用的成员变量；例如ch[0]；

# 内部类与外部类

1. 	内部类的方法中可以直接使用外部类的成员变量，即使是privaed的  
2. 	内部类可以直接调用外部类的方法，即使是private的；------->内用外随意，外用内需要new 
3. 	外部类方法或者变量与内部类重名时，使用Outer.this.方法可以调用外部类的方法或变量；  
	如果只用this.只能调用内部类里面的  
	static里面不能通过Outer.this.调用外部类对象；但是可以调用this.来调用自身成员变量
4. 	外部类不能直接调用内部类的成员变量以及方法，只能在创建内部类对象时才能调用
5.	内部类构造方法或者构造代码块只有在创建内部类对象时才能调用
6. 	外部类的静态方法不能直接new内部类来调用内部类的方法和变量，必须先new外部类再new内部类对象
7. 	非静态内部类不能有静态方法或者变量或者构造方法（static）
8. 	匿名内部类不能有构造方法，但是可以有代码块