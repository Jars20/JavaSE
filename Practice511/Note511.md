# Note
1. interface的static方法前的访问权限修饰符或者是public或者是private，且必须有方法实现
	相对于default，
2. interface中的方法修饰符有什么限制：
	如果是抽象方法，必须是public的，可以不写访问修饰符，不写默认是public
3. 接口相对于方法的模板（行为），抽象类作为成员算法的模板
4. 接口中可以有Priva的具体方法实现


# Attention：
1. 向上转型：子类对象转为父类，父类可以是接口。公式：Father f = new Son();Father是父类或接口，son是子类。
   向下转型：父类对象转为子类。公式：Son s = (Son)f;  

   注意：向上转型不需要强制类型转换。向上转型后父类的引用所指向的属性为父类的属性，如果子类重写了父类的方法，那么父类引用所指向的方法调用所指向的方法为子类的方法，这个我们称之为动态绑定。  
   向上转型后父类引用不能调用子类自己的方法。  

   注意：向下转型需要强制类型转换，并且需要考虑安全性。如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的。虽然编译不会出错，但是运行时会出现java.lang.ClassCastException错误。  

>可以通过使用instanceof来避免这种出错。只有先经过向上转型的对象才能继续向下转型。(instanceof是向下转型时使用的)    

2. String的语法： 
	String s1 = new String(s2);				//新开辟一块String，并把s2复制给s1  
	String s1 = s2；							//s1地址赋值给s2  

3. 三目运算符在编译时, 就已经确定了三目运算的返回值类型，而且只能是一种类型，不管你的三目条件判断为true 或 false 都是返回同一种类型。  
如果返回值1和返回值2都是同种类型，那么三目最终的返回类型就是这种类型  
如果返回值1和返回值2不是同种类型，那么三目最终的返回类型是这两种类型的相同最小父类（最接近的父类，如果没有则返回Object，例如Integer和String最终返回的将是Object）。  

4. 无论父类还是子类，类中new子类，均不影响调用。 
   同理，Method的先后顺序也不影响调用 

5. 	构造方法不能被继承！！！因此不能被重写。  
	子类构造方法构造子类时，默认调用父类无参数构造方法，父类无参数构造方法为（default）；  
	注意！：若父类没有无参构造方法，则必须在子类的构造方法中必须要先用（super(参数)）调用父类的有参的构造方法 ;


6. override中调用父类原方法。不影响方法的执行。正常按顺序执行父类的原方法，之后执行子类的重写方法
